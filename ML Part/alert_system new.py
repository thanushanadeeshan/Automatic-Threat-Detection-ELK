
import asyncio
import smtplib
import logging
import sys
import os
import time
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from elasticsearch import Elasticsearch
import urllib3
from concurrent.futures import ThreadPoolExecutor

# -------------------------------
# 1. SYSTEM CONFIGURATION
# -------------------------------
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# FIX: Force Windows Console to accept UTF-8 Emojis (üõ°Ô∏è, ‚úÖ, ‚ùå)
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

# Logging Setup
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [%(levelname)s] - %(message)s',
    handlers=[
        logging.FileHandler("alert_system.log", encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)

class Config:
    # Elastic Connection
    ES_HOST = "https://localhost:9200"
    ES_USER = "elastic"
    ES_PASS = "vQ8QSdp3jJtUw9mQcVlM"
    ALERT_INDEX = "ml-threats-report"
    
    # Email Settings
    ENABLE_EMAIL = True
    SENDER_EMAIL = "huntingthreat24@gmail.com"
    SENDER_APP_PASSWORD = "pyjh dlcv wlig akaq" 
    RECEIVERS = ["thanushanadeeshan@gmail.com", "Jananiasanthika18@gmail.com"]
    
    # Logic Settings
    CHECK_INTERVAL = 10     # Check every 10 seconds
    LOOKBACK_WINDOW = "1h"  # Look back 1 hour
    CACHE_TTL = 86400       # Clear Alert ID cache after 24 hours (prevent memory leak)

# -------------------------------
# 2. EMAIL TEMPLATE ENGINE (ENHANCED)
# -------------------------------
def create_html_email(threat_data):
    """Generates a professional HTML email template for the alert."""
    
    # Extract data with defaults
    t_type = threat_data.get('threat_type', 'Unknown Anomaly')
    t_ip = threat_data.get('attacker_ip', 'Unknown')
    t_time = threat_data.get('@timestamp', 'N/A')
    req_count = threat_data.get('request_count', 0)
    
    html = f"""
    <html>
    <head>
        <style>
            body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #333; background-color: #f4f4f4; }}
            .container {{ width: 100%; max-width: 600px; margin: 20px auto; background: #fff; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow: hidden; }}
            .header {{ background-color: #d32f2f; color: white; padding: 25px; text-align: center; }}
            .content {{ padding: 30px; }}
            .metric-box {{ background-color: #fff5f5; padding: 20px; border-left: 5px solid #d32f2f; margin-bottom: 20px; border-radius: 4px; }}
            .details-table {{ width: 100%; border-collapse: collapse; margin-top: 15px; }}
            .details-table td {{ padding: 8px; border-bottom: 1px solid #eee; }}
            .footer {{ background-color: #333; color: #aaa; padding: 15px; text-align: center; font-size: 12px; }}
            .badge {{ background: #d32f2f; color: white; padding: 3px 8px; border-radius: 4px; font-size: 12px; font-weight: bold; }}
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>üõ°Ô∏è SOC Alert: Critical</h1>
                <p>ML Threat Detection Engine</p>
            </div>
            <div class="content">
                <p><strong>Hello Security Team,</strong></p>
                <p>The Automated Response System has detected a high-confidence security anomaly requiring immediate attention.</p>
                
                <div class="metric-box">
                    <h2 style="margin-top:0;">{t_type}</h2>
                    <table class="details-table">
                        <tr><td><strong>Source IP:</strong></td><td>{t_ip}</td></tr>
                        <tr><td><strong>Severity:</strong></td><td><span class="badge">CRITICAL</span></td></tr>
                        <tr><td><strong>Time Detected:</strong></td><td>{t_time}</td></tr>
                    </table>
                </div>

                <h3>Technical Forensics:</h3>
                <ul>
                    <li><strong>Request Velocity:</strong> {req_count} requests/min</li>
                    <li><strong>Error Rate:</strong> {threat_data.get('error_count', 0)} errors/min</li>
                    <li><strong>Detection Model:</strong> {threat_data.get('detection_engine', 'Standard ML')}</li>
                </ul>
                
                <p style="margin-top:20px;"><em>Please investigate the source IP immediately and verify firewall rules.</em></p>
            </div>
            <div class="footer">
                Generated by Thanusha's ELK Stack | Automated Incident Response
            </div>
        </div>
    </body>
    </html>
    """
    return html

# -------------------------------
# 3. ASYNC ALERT MANAGER
# -------------------------------
class AlertManager:
    def __init__(self):
        # Dictionary for cache: {alert_id: timestamp_added}
        self.sent_cache = {} 
        self.es = Elasticsearch(
            Config.ES_HOST,
            basic_auth=(Config.ES_USER, Config.ES_PASS),
            verify_certs=False,
            ssl_show_warn=False
        )
        # Executor for running blocking SMTP calls in a separate thread
        self.executor = ThreadPoolExecutor(max_workers=3)
        self._check_connection()

    def _check_connection(self):
        try:
            if self.es.ping():
                logging.info(f"‚úÖ Connected to Elasticsearch at {Config.ES_HOST}")
            else:
                logging.error("‚ùå Connection Failed! Check ES status.")
                sys.exit(1)
        except Exception as e:
            logging.error(f"‚ùå Critical Error connecting to ES: {e}")
            sys.exit(1)

    def _clean_cache(self):
        """Remove alerts from cache that are older than 24 hours to save memory."""
        current_time = time.time()
        # Create a list of keys to remove
        to_remove = [k for k, v in self.sent_cache.items() if (current_time - v) > Config.CACHE_TTL]
        for k in to_remove:
            del self.sent_cache[k]
        if to_remove:
            logging.info(f"üßπ Cache cleanup: Removed {len(to_remove)} old alert records.")

    def fetch_new_threats(self):
        """Query ES for threats in the lookback window."""
        query = {
            "query": {
                "range": {
                    "@timestamp": {
                        "gte": f"now-{Config.LOOKBACK_WINDOW}",
                        "lt": "now"
                    }
                }
            }
        }
        try:
            response = self.es.search(index=Config.ALERT_INDEX, body=query)
            return response['hits']['hits']
        except Exception:
            # Silent fail is okay here, index might not exist yet if script starts before ingestion
            return []

    def _send_smtp_blocking(self, threat_doc):
        """
        The actual blocking SMTP code. 
        This is run in a separate thread to not freeze the Async Loop.
        """
        src = threat_doc['_source']
        ip = src.get('attacker_ip', 'Unknown')
        
        msg = MIMEMultipart("alternative")
        msg['From'] = Config.SENDER_EMAIL
        msg['To'] = ", ".join(Config.RECEIVERS)
        msg['Subject'] = f"üö® ALERT: {src.get('threat_type')} Detected from {ip}"

        html_content = create_html_email(src)
        msg.attach(MIMEText(html_content, 'html'))

        try:
            if Config.ENABLE_EMAIL:
                server = smtplib.SMTP('smtp.gmail.com', 587)
                server.starttls()
                server.login(Config.SENDER_EMAIL, Config.SENDER_APP_PASSWORD)
                server.send_message(msg)
                server.quit()
                logging.info(f"üìß Email Sent successfully regarding IP: {ip}")
            else:
                logging.info(f"üìù [DRY RUN] Email generated for {ip}")
            return True
        except Exception as e:
            logging.error(f"‚ùå SMTP Error: {e}")
            return False

    async def process_alert(self, threat):
        """Async wrapper to offload email sending to a thread."""
        loop = asyncio.get_running_loop()
        # Run the blocking SMTP function in the ThreadPool
        success = await loop.run_in_executor(self.executor, self._send_smtp_blocking, threat)
        return success

    async def monitor(self):
        """Main Async Loop"""
        logging.info("üõ°Ô∏è  Professional Threat Alert System Started...")
        logging.info(f"üì° Monitoring Index: {Config.ALERT_INDEX}")

        while True:
            # 1. Housekeeping
            self._clean_cache()

            # 2. Fetch Data
            threats = self.fetch_new_threats()
            
            # 3. Process Threats
            if threats:
                for threat in threats:
                    threat_id = threat['_id']
                    
                    # Deduplication Check
                    if threat_id not in self.sent_cache:
                        logging.info(f"‚ö° New Threat Detected! ID: {threat_id[:8]}...")
                        
                        # Send Email (Non-blocking)
                        is_sent = await self.process_alert(threat)
                        
                        if is_sent:
                            # Add to cache with current timestamp
                            self.sent_cache[threat_id] = time.time()
            
            # 4. Sleep (Non-blocking)
            await asyncio.sleep(Config.CHECK_INTERVAL)

# -------------------------------
# 4. ENTRY POINT
# -------------------------------
if __name__ == "__main__":
    manager = AlertManager()
    try:
        # Windows AsyncIO Policy Fix (if needed for specific Python versions)
        if sys.platform == 'win32':
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
            
        asyncio.run(manager.monitor())
    except KeyboardInterrupt:
        logging.info("üõë Alert System Shutting Down...")
        manager.executor.shutdown(wait=False)